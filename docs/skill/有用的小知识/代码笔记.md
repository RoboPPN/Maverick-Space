## 所有按引用传递的参数必须加上 const. 这样做的好处是？

在C++中，按引用传递参数时，使用const关键字可以将参数声明为"const引用"。这意味着在函数中无法修改该参数的值。以下是将参数声明为const引用的好处：

1. 避免无意的修改：const关键字确保函数内部不会无意间修改传入的参数的值。这可以帮助预防程序中的错误，特别是当参数被多个函数使用时。
2. 安全性和可维护性：使用const可以增加代码的可读性和可维护性。通过在函数声明中指定参数为const引用，可以清晰地表明函数不会修改该参数的值。这使得代码更易于理解，并且在后续的代码维护和调试过程中更容易追踪参数的用法。
3. 支持传递临时对象：当传递临时对象（例如，函数返回的临时对象）作为引用参数时，将其声明为const引用是必要的，因为临时对象无法被非const引用所绑定。
4. 优化性能：使用const引用作为参数可以避免不必要的复制。如果参数不是const引用，而是普通的非const引用，那么在函数调用时，编译器将创建参数的副本。而使用const引用则可以避免这种复制开销。



## ROS添加自定义消息类型，如何修改CMakeLists.txt的内容

在写CMakeLists.txt时，如要添加自定义消息类型，在find_package加的是message_generation，在catkin_package加的是message_runtime，在package.xml加的是

```xml
  <build_depend>message_generation</build_depend>
  <exec_depend>message_runtime</exec_depend>
```



## 当回调函数写在类中，如何写subscribe的回调函数

class ChargeInfo
{
public:
​    ChargeInfo(){
​        pub = nh.advertise<charge_ppn::ChargeData>("charge_data",10);
	//这里要注意，InfoCallback是ChargeInfo类中的函数，所以在定义回调函数时应使用域修饰符：：加上类空间，以及加上this引用。
​        sub=nh.subscribe("/BMS_status", 10 , &ChargeInfo::InfoCallback,this);	
​    }
​    void InfoCallback(const scout_msgs::ScoutBmsStatus::ConstPtr& battery_msgs);
}

## C++ + yaml对yaml文件读取以及修改yaml文件数据

yaml文件数据如下：

```yaml
Charge_single_time: 12
Charge_status: 0
Charge_counts: 30
Charge_total_time: 8155
```



```cpp
#include <iostream>
#include<yaml-cpp/yaml.h>
....................
YAML::Node config = YAML::LoadFile("/home/agilex/freego_ws/src/board_ros/board_yaml/charge_config.yaml");
// 访问charge_info.yaml中的数据
int64_t chargeStatus = config["Charge_status"].as<int64_t>();
int64_t chargeSingleTime = config["Charge_single_time"].as<int64_t>();
int64_t chargeTotalTime = config["Charge_total_time"].as<int64_t>();
int64_t chargeCounts = config["Charge_counts"].as<int64_t>();
.....................
//修改YAML文件Charge_single_time的值
config["Charge_single_time"] = 1 ;
// 写回到文件
std::ofstream fout("/home/agilex/freego_ws/src/board_ros/board_yaml/charge_config.yaml");
// 将修改后的 YAML 数据写入文件
fout << config;  
//关闭文件
fout.close();
```



## autoware main函数写法

```cpp

void ChargeInfo::Run(){
    ros::Rate loop_rate(1);  // 频率：1 HZ
    while(ros::ok()){
        pub_info();  //主要执行的核心功能函数
        loop_rate.sleep();
        ros::spinOnce();
    }
}

int main(int argc,char **argv)
{
    ros::init(argc,argv,"charge_node");
    ChargeInfo info;
    info.Run();
    return 0;
}
```



## MySQL创建navis 任务的三个表格

```cpp
use navis_task_data;
CREATE TABLE Task_Common (
    task_id INT PRIMARY KEY AUTO_INCREMENT,
    task_name VARCHAR(100),
    edited_name VARCHAR(100),
    evadible INT,
    grid_item_idx INT,
    map_name VARCHAR(100),
    task_mode VARCHAR(50),
    person_name VARCHAR(100),
    remark VARCHAR(200),
    speed FLOAT
);
CREATE TABLE Task_Points (
    point_id INT PRIMARY KEY AUTO_INCREMENT,
    task_id INT,
    point_name VARCHAR(100),
    point_type VARCHAR(50),
    position_x float,
    position_y float,
    position_theta float,
    cpx float,
    cpy float,
    is_new TINYINT(1),
    in_dex VARCHAR(50),
    FOREIGN KEY (task_id) REFERENCES Task_Common(task_id)
);
CREATE TABLE Point_Actions (
    action_id INT PRIMARY KEY AUTO_INCREMENT,
    point_id INT,
    action_order INT,
    action_name VARCHAR(100),
    action_type VARCHAR(50),
    action_content VARCHAR(100),
    FOREIGN KEY (point_id) REFERENCES TaskPoints(point_id)
);
-- 在这个设计中，我们使用了外键约束来建立表之间的关联关系。Tasks表中的task_id被用作TaskPoints表的外键，表示每个任务点所属的任务。
-- TaskPoints表中的point_id被用作PointActions表的外键，表示每个动作所属的任务点。
```



## 检测是否存在相同的`task_name`并退出程序

```pyth
try:
    task_name = '4555'

    # 查询是否存在相同的task_name
    select_query = "SELECT * FROM Task_Common WHERE task_name = %s"
    cursor.execute(select_query, (task_name,))
    result = cursor.fetchone()

    if result:
        print("存在相同的task_name，程序退出")
        exit()
```



## chrono库计算程序运行时间

```cpp
#include<chrono>
#include<thread>
std::chrono::steady_clock::time_point start;
std::chrono::steady_clock::time_point end ;
start = std::chrono::steady_clock::now();
..........
end = std::chrono::steady_clock::now();
std::chrono::duration<double> duration = end - start;
chargeSingleTime = duration.count(); 	//计算start与end的时间间隔
..........
std::this_thread::sleep_for(std::chrono::milliseconds(100)); //延时100毫秒
```



## 头文件首先需要这样定义

```cpp
#pragma once

#ifndef _CHARGE_INFO_H_

#define _CHARGE_INFO_H_

#endif
```

在C++头文件中使用#ifndef、#define和#endif是为了防止头文件的重复包含，这是一种常见的防御性编程技术，也被称为头文件保护或者条件编译。



## const 与 #define

1、const的作用是让某值保持不变，不可修改该值

2、C++中的const变量虽然也会占用内存，也能使用&获取它的地址，但在使用时更像编译时期的#define。 #define也是值替换，可见范围也仅限于当前文件。

3、但是，#define定义的常亮仅仅是字符串的替换，不会进行类型检查，而const定义的变量是会让编译器进行类型检查的，相比于#define更安全。

4、墙裂建议使用const代替#define宏定义

使用`const`关键字具有以下优势：

1. **类型安全**：`const`关键字提供了类型安全性，编译器可以对常量进行类型检查，并确保其值与定义的类型匹配。相比之下，使用宏定义时没有类型检查，可能会导致潜在的错误。
2. **作用域限制**：`const`常量受限于其定义的作用域。它们可以在特定的作用域内访问，并且不会在其他作用域中引起命名冲突。而宏定义则没有这样的限制，它们在整个文件中都是可见的。
3. **符号表信息**：使用`const`关键字定义的常量在符号表中会有对应的信息，包括名称和类型。这对于调试和代码理解非常有帮助。而宏定义只是简单地进行文本替换，没有符号表信息。

代码示例：

```cpp
#define N 100
#define int N = 100
```



## 内联函数替换带参数的宏

```cpp
inline double sq(double Y)
{
    return Y*Y;
}
```

墙裂推荐使用内联函数代替带参数的宏。



## 使用new在堆创建对象

```cpp
Student *pStu = new Student
```

使用new在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，在借助指针来访问它的成员变量或成员函数。

有了对象指针后，可以使用->来访问对象的成员变量和成员函数。

使用`new`在堆上创建对象并通过指针访问其成员变量或成员函数有以下好处：

1、动态内存管理：通过在堆上创建对象，可以手动控制对象的生命周期。可以在需要时创建对象，而不是在编译时分配固定大小的内存。同时，可以在不再需要对象时显示释放内存，避免内存泄漏。

2、对象生存期延长：通过使用指针访问在堆上创建的对象，可以在对象超出其作用域之后继续访问该对象。这对于在函数之间传递对象或在程序的不同部分共享非常有用。

3、动态多态性：通过使用基类指针指向派生类对象，可以实现多态性。这允许在运行时通过基类指针调用派生类的特定成员函数，从而实现动态绑定和多态行为。

4、对象共享和复用：通过将对象的指针传递给其他部分的代码，可以实现对象的共享和复用。多个部分可以引用和操作相同的对象，避免创建多个副本。

5、灵活性和动态性：通过使用指针访问对象，可以在运行时根据需要更改对象的状态或属性。可以根据实际情况动态地创建、销毁和修改对象，以适应不同的需求和变化。



## C++11 shared_ptr智能指针

shared_ptr是C++11里的新特性，其包装了new操作符在堆上分配动态对象。如：

```cpp
#include<memory>
shared_ptr<int> sp1(new int(100));
//相当于
int *sp1 = new int(100);
auto sp1 = make_shared<int>(100);
```

shared_ptr是一种共享所有权的智能指针，它采用引用计数的机制跟踪指向对象的引用情况，并在没有引用时自动释放内存。



### std::shared_ptr的实现思想

1、引用计数：shared_ptr内部维护了一个引用计数的计数器，用于记录有多少个指针共享一个对象。

2、对象指针：shared_ptr包含一个指向动态分配的对象指针，以及一个指向引用计数的计数器指针。

3、构造和析构：当创建一个shared_ptr时，它会通过构造函数获取对象的指针，并创建一个引用计数对象，初始计数为 1 。当shared_ptr被销毁时，析构函数会递减引用计数，并在计数变为0时释放对象的内存。

4、拷贝和赋值：shared_ptr支持复制和赋值操作。无论何时我们拷贝一个`shared_ptr`，计数器都会递增。例如，当用一个`shared_ptr`初始化另一个`shared_ptr`，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。   当我们给`shared_ptr`赋予一个新值或是`shared_ptr`被销毁（例如一个局部的`shared_ptr`离开其作用域）时，计数器就会递减。

5、析构时释放内存：当引用计数减少到0时，表示没有指针指向对象，此时会自动释放对象的内存。



下面是`std::shared_ptr`的核心代码示例，用于说明其实现的一种简化形式：

```cpp
template <typename T>
class shared_ptr {
public:
    shared_ptr(T* ptr) {
        // 构造函数获取对象指针，创建引用计数对象
        data_ = ptr;
        ref_count_ = new int(1);
    }

    ~shared_ptr() {
        // 析构函数递减引用计数，释放对象内存
        if (--(*ref_count_) == 0) {
            delete data_;
            delete ref_count_;
        }
    }

    // 拷贝构造函数
    shared_ptr(const shared_ptr<T>& other) {
        data_ = other.data_;
        ref_count_ = other.ref_count_;
        (*ref_count_)++;
    }

    // 赋值操作符重载
    shared_ptr<T>& operator=(const shared_ptr<T>& other) {
        if (this != &other) {
            if (--(*ref_count_) == 0) {
                delete data_;
                delete ref_count_;
            }

            data_ = other.data_;
            ref_count_ = other.ref_count_;
            (*ref_count_)++;
        }
        return *this;
    }

private:
    T* data_;     // 对象指针
    int* ref_count_;   // 引用计数指针
};
```

这只是一个简化的示例，实际的`std::shared_ptr`还包含了更多的功能和优化，例如支持自定义删除器（deleter）、异常安全等。

需要注意的是，C++11引入了标准库中的`std::shared_ptr`，它的实现可能与上述示例代码有所不同，且更加复杂和高效。上述代码只是为了展示`std::shared_ptr`的基本实现原理。



## shared_ptr<T>模板类提供的成员方法

![image-20230627105703652](/home/agx-ppn/.config/Typora/typora-user-images/image-20230627105703652.png)

- `operator=()`: 重载赋值号，使得同一类型的`shared_ptr`智能指针可以相互赋值。

  ```cpp
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
      std::shared_ptr<int> ptr2;
      // ptr2 = ptr1;  //将ptr1赋值给ptr2，共享一个对象
      std::cout<<ptr2.use_count()<<std::endl;
  ```

- `operator*()`: 重载 `*` 号，获取当前`shared_ptr`智能指针对象指向的数据。

  ```cpp
      std::shared_ptr<int> ptr = std::make_shared<int>(42);
      int value = *ptr;   //获取指针指向的数据
  ```

- `operator->()`: 重载 `->` 号，当智能指针指向的数据类型为自定义的结构体时，通过 `->` 运算符可以获取其内部的指定成员。

  ```cpp
  #include<iostream>
  #include<memory>
  class TestPoint
  {
  public:
      TestPoint(/* args */);
      ~TestPoint();
      int get_number(const int a);
  };
  int TestPoint::get_number(const int a){
      return a;
  }
  int main(){
      std::shared_ptr<TestPoint> ptr = std::make_shared<TestPoint>();
      ptr->TestPoint();
      ptr->get_number(3);   //通过指针访问内部成员函数
      std::cout<<ptr->get_number(3)<<std::endl;
      ptr->~TestPoint();
      return 0;
  }
  ```

  上面这版的代码写法是错的，因为：

  1、智能指针已经在`std::make_shared<TestPoint>()`中调用了构造函数。

  2、智能指针会在其作用域结束时自动调用析构函数释放资源，不需要显示调用析构函数。

  下面是修改后的代码：

  ```cpp
  #include<iostream>
  #include<memory>
  
  class TestPoint
  {
  public:
      TestPoint();
      ~TestPoint();
      int get_number(const int a);
  };
  
  TestPoint::TestPoint()
  {
      std::cout << "TestPoint constructor" << std::endl;
  }
  
  TestPoint::~TestPoint()
  {
      std::cout << "TestPoint destructor" << std::endl;
  }
  
  int TestPoint::get_number(const int a)
  {
      return a;
  }
  
  int main()
  {
      std::shared_ptr<TestPoint> ptr = std::make_shared<TestPoint>();
      ptr->get_number(3);   //通过指针访问内部成员函数
      std::cout << ptr->get_number(3) << std::endl;
      return 0;
  }
  
  ```

  修正的地方如下：

  1、删除了不必要的`TestPoint`构造函数调用：`ptr->TestPoint();`，因为智能指针已经在 `std::make_shared<TestPoint>()` 中调用了构造函数。

  2、删除了显示调用析构函数的语句：`ptr->~TestPoint();`。智能指针会在其作用域结束时自动调用析构函数释放资源，不需要显式调用析构函数。

  3、将`TestPoint`类的构造函数和析构函数定义移到类外部实现。



​	Q: 如果将上述代码：std::shared_ptr<TestPoint> ptr = std::make_shared<TestPoint>();   改成      std::shared_ptr<TestPoint> ptr ;   会有什么样的结果？

​	A: 会导致指针ptr没有有效地指向一个对象。这将产生以下结果：当尝试通过`ptr->get_number(3);`调用指针的成员函数时，会出现未定义行为，因为`ptr`为空指针，没有有效对象可调用成员函数。（但我运行还是正常运行，指示运行结果少了构造和析构函数的调用）

### make_shared函数

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。

此函数在动态内存（堆）中分配一个对象并初始化它，返回指向此对象的`shared_ptr`。

与智能指针一样，`make_shared`也定义在头文件`memory`中。

代码示例：

```cpp
// 指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
```



- `swap()`: 交换两个相同类型`shared_ptr`智能指针的内容。

  ```cpp
  #include<iostream>
  #include<memory>
  int main()
  {
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
      std::shared_ptr<int> ptr2 = std::make_shared<int>(24);
      ptr1.swap(ptr2); // 交换ptr1和ptr2的内容
      std::cout << *ptr1 <<"   "<<*ptr2 << std::endl;
      return 0;
  }
  ```

- `reset()`:当函数没有实参时，该函数会使当前`shared_ptr`所指堆内存的引用计数减1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的`shared_ptr`对象会获得该存储空间的所有权，并且引用计数的初始值为1。

  ```cpp
  #include<iostream>
  #include<memory>
  int main()
  {
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
      ptr1.reset();   //释放所指堆内存，ptr1变为nullptr，此时如果使用cout打印ptr1的值会出现 段错误 (核心已转储) 的错误
      std::shared_ptr<int> ptr2;
      ptr2.reset(new int(24));    //重置ptr2为新的堆内存
      std::cout <<*ptr2 << std::endl;
      return 0;
  }
  ```

- `use_count()`:返回与当前`shared_ptr`对象（包括它自己）指向相同的所有`shared_ptr`对象的数量。它返回一个整数值，表示共享指针的引用计数。

  ```cpp
  #include<iostream>
  #include<memory>
  int main()
  {
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
      int count = ptr1.use_count(); //返回共享指针的数量，此处为1
      std::cout<<count<<std::endl;    
  
      ptr1.reset();   //释放所指堆内存，ptr1变为nullptr
      count = ptr1.use_count(); //返回共享指针的数量，此处为0
      std::cout<<count<<std::endl;    
  
      std::shared_ptr<int> ptr2;
      ptr2.reset(new int(24));    //重置ptr2为新的堆内存
      count = ptr2.use_count(); //返回共享指针的数量，此处为1
      std::cout<<count<<std::endl;  
  
      std::shared_ptr<int> ptr3;
      ptr3 = ptr2;
      count = ptr3.use_count();   //返回共享指针的数量，此处为2
      std::cout<<count<<std::endl;
  
      auto p(ptr3);
      count = p.use_count();  //返回共享指针的数量，此处为3
      std::cout<<count<<std::endl;
  
      return 0;
  }
  ```

- `operator bool()`:判断当前`shared_ptr`对象是否为空智能指针，如果是空指针，返回false；反之，返回true。

  ```cpp
  #include<iostream>
  #include<memory>
  int main()
  {
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);  //有值，不为空指针
      if(ptr1){
          std::cout<<"指针不为空..."<<std::endl;
      }
      else{
          std::cout<<"指针为空..."<<std::endl;
      } 
  
      ptr1.reset();   //将ptr1置为空指针
      if(ptr1){
          std::cout<<"指针不为空..."<<std::endl;
      }
      else{
          std::cout<<"指针为空..."<<std::endl;
      } 
  
      return 0;
  }
  ```

- `unique()`:判断当前`shared_ptr`对象指向的堆内存是否不再有其他`shared_ptr`对象再指向它。如果返回值为`true`，表示当前对象是唯一指向该堆内存的智能指针；如果返回值为`false`，表示还有其他智能指针指向同一块堆内存。

  ```cpp
  #include<iostream>
  #include<memory>
  int main()
  {
      std::shared_ptr<int> ptr1 = std::make_shared<int>(42);  //有值，不为空指针
      bool isUnique1 = ptr1.unique(); // 返回true，无其他指针指向堆内存
  
      if(isUnique1){
          std::cout<<"没有其他对象再指向ptr1..."<<std::endl;
      }
      else{
          std::cout<<"有..."<<std::endl;
      } 
  
      std::shared_ptr<int> ptr2;
      ptr2 = ptr1;        
      bool isUnique2 = ptr2.unique(); // 返回false，有其他指针指向堆内存
  
      if(isUnique2){
          std::cout<<"没有其他对象再指向ptr2..."<<std::endl;
      }
      else{
          std::cout<<"有..."<<std::endl;
      } 
  
      return 0;
  }
  ```

- `get()`:获取`shared_ptr`对象内部包含的普通指针。

  ```cpp
  std::shared_ptr<int> ptr = std::make_shared<int>(42);
  int* rawPtr = ptr.get(); // 获取内部的普通指针
  ```



## C++11 weak_ptr智能指针

虽然C++11标准将`weak_ptr`定位为智能指针的一种，但该类型指针不单独使用，只能和`shared_ptr`类型指针搭配使用。

我们还可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。

需要注意的是，当`weak_ptr`类型指针指向和某一`shared_ptr`指针相同时，`weak_ptr`指针并不会使所指堆内存的引用计数加1；同样，当`weak_ptr`指针被释放时，之前所指堆内存的引用计数也不会因此而减1。也就是说，`weak_ptr`类型指针并不会影响所指堆内存空间的引用计数。这样做的好处如下：

1. 防止循环引用：`std::weak_ptr`可以用于解决循环引用的问题（下文会将）。循环引用指的是两个或多个对象相互持有对方的`std::shared_ptr`，导致它们之间的引用计数永远不会降为零，从而无法释放内存。通过使用`std::weak_ptr`来解决循环引用，可以打破循环依赖关系，允许对象在不再被其他智能指针引用时正确地释放。
2. 安全地访问对象：由于`std::weak_ptr`不会增加所指堆内存的引用计数，即使原始的`std::shared_ptr`已经释放了内存，使用`std::weak_ptr`仍然可以安全地检查对象是否存在，而不会访问已释放的内存。这可以避免悬空指针的问题。
3. 提高性能：由于`std::weak_ptr`不会增加引用计数，因此在访问对象时不需要进行引用计数的增减操作，从而提高了性能。

**weak_ptr<T>模板类中没有重载*和->运算符，这也就意味着，weak_ptr类型指针只能访问某一`shared_ptr`指针所指的堆内存空间，无法对其进行修改。**

### shared_ptr使用陷阱--循环引用问题

`shared_ptr`作为被管控的对象的成员时，小心因循环引用造成无法释放资源！

如下代码很好解释了什么是循环引用：

1、Boy类中有Girl的智能指针；

2、Girl类中有Boy类的智能指针；

3、当他们交叉互相持有对方的管理对象时...

```cpp
#include <iostream>
#include <string>
#include <memory>

using namespace std;
class Girl;
class Boy {
public:
	Boy() {
		cout << "Boy 构造函数" << endl;
	}
	~Boy() {
		cout << "~Boy 析构函数" << endl;
	}
	void setGirlFriend(shared_ptr<Girl> _girlFriend) {
		this->girlFriend = _girlFriend;
	}
private:
	shared_ptr<Girl> girlFriend;
};
class Girl {
public:
	Girl() {
		cout << "Girl 构造函数" << endl;
	}
	~Girl() {
		cout << "~Girl 析构函数" << endl;
	}
	void setBoyFriend(shared_ptr<Boy> _boyFriend) {
		this->boyFriend = _boyFriend;
	}
private:
	shared_ptr<Boy> boyFriend;
};
void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	// 陷阱用法
	spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);
	// 此时boy和girl的引用计数都是2
}
int main(void) {
	useTrap();
	system("pause");
	return 0;
}
```

运行结果为：

```bash
Boy 构造函数
Girl 构造函数
```

可看出，程序结束了，但是并没有释放内存。



### weak_ptr模板类提供的成员方法

| operator=() | 重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。 |
| :---------: | ------------------------------------------------------------ |
|   swap(x)   | 其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。 |
|   reset()   | 将当前 weak_ptr 指针置为空指针。                             |
| use_count() | 查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。   |
|  expired()  | 判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。 |
|   lock()    | 如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。 |

operator=()、swap()、reset()、use_count()成员方法和shared_ptr<T>方法一样，我主要来讲讲expired()以及lock()这两个成员方法。

1、`expired()`: `expired()`函数用于判断当前`weak_ptr`指针是否过期，即指针为空或者指向的堆内存已经被释放。如果返回值为`true`，表示指针已过期；如果返回值为`false`，表示指针仍然有效。

```cpp
std::weak_ptr<int> weakPtr;
if (weakPtr.expired()) {
    // 执行此处代码，指针已过期
} else {
    // 执行此处代码，指针仍然有效
}
```

2、`lock()`: `lock()`函数用于获取一个与当前`weak_ptr`指向相同对象的`std::shared_ptr`指针。如果当前`weak_ptr`已经过期（即指向的对象已经被释放），`lock()`函数会返回一个空的`std::shared_ptr`；反之，如果`weak_ptr`仍然有效，`lock()`函数会返回一个指向相同对象的非空的`std::shared_ptr`。

```cpp
std::weak_ptr<int> weakPtr;
std::shared_ptr<int> sharedPtr = weakPtr.lock();
if (sharedPtr) {
    // 执行此处代码，sharedPtr非空，指针仍然有效
} else {
    // 执行此处代码，sharedPtr为空，指针已过期
}
```



## shared_ptr 和 weak_ptr配合使用

```cpp
std::shared_ptr<roborts_costmap::CostmapInterface> local_cost;
std::weak_ptr<roborts_costmap::CostmapInterface> local_cost_;  
local_cost_ = local_cost;
local_cost_.lock()->GetRobotPose(robot_pose);
```

上面代码使用了C++智能指针`std::shared_ptr`和`std::weak_ptr`。

​	首先，`std::shared_ptr<roborts_costmap::CostmapInterface> local_cost;`创建了一个`std::shared_ptr`类型的指针`local_cost`，指向类型为`roborts_costmap::CostmapInterface`的对象。`std::shared_ptr`是一种共享所有权的智能指针，它可以自动跟踪指向的对象被引用的次数，并在没有引用时自动释放内存。

​	接下来，`std::weak_ptr<roborts_costmap::CostmapInterface> local_cost_;`创建了一个`std::weak_ptr`类型的指针`local_cost_`，指向相同的对象类型。`std::weak_ptr`是一种弱引用的智能指针，它可以共享对对象的访问，但不会增加引用计数。当对象的引用计数降为零时，`std::weak_ptr`也无法访问对象。

​	最后，`local_cost_ = local_cost;`将`local_cost`的值赋给了`local_cost_`。这里的赋值操作并不会增加对象的引用计数，因为`local_cost_`是一个弱引用。通过将`std::shared_ptr`赋值给`std::weak_ptr`，可以实现对相同对象的共享访问，而不会增加引用计数。

​	总结，上面的代码创建了一个`std::shared_ptr`和一个`std::weak_ptr`，它们指向相同的对象，通过这样的方式，可以共享访问对象，并确保不再需要对象时适当地释放内存，以防内存泄漏。



再举一个栗子：

```cpp
void ChargeInfo::Run(){
    ros::Rate loop_rate(1);
    while(ros::ok()){
        pub_info();
        loop_rate.sleep();
        ros::spinOnce();
    }
}

int main(int argc,char **argv)
{
    ros::init(argc,argv,"charge_node");

    std::shared_ptr<ChargeInfo> charge_ptr = std::make_shared<ChargeInfo>();
    std::weak_ptr<ChargeInfo> weak_ptr = charge_ptr;
    std::cout<<"引用数量为：  "<<weak_ptr.use_count()<<std::endl;   //不会增加引用次数，引用次数为 1
    weak_ptr.lock()->Run();
    
    return 0;
}
```



## 类成员变量赋值问题

类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。



```cpp
#include <ros/ros.h>
#include <nav_msgs/Odometry.h>
#include <tf/tf.h>

ros::Time previous_time;
double previous_yaw = 0.0;
double total_rotation_distance = 0.0;
double radius = 0.5; // 假设机器人的半径为0.5米

void odomCallback(const nav_msgs::Odometry::ConstPtr& msg)
{
    // 提取姿态信息（四元数）
    double current_yaw = tf::getYaw(msg->pose.pose.orientation);

    // 获取当前时间
    ros::Time current_time = msg->header.stamp;

    // 计算时间间隔
    double dt = (current_time - previous_time).toSec();

    // 计算角度差（旋转角度）
    double rotation_angle = current_yaw - previous_yaw;

    // 调整角度差到[-π, π]范围内
    if (rotation_angle > M_PI)
        rotation_angle -= 2 * M_PI;
    else if (rotation_angle < -M_PI)
        rotation_angle += 2 * M_PI;

    // 计算旋转的弧长（旋转距离）
    double rotation_distance = radius * std::abs(rotation_angle);

    // 计算平均旋转速度
    double average_rotation_speed = rotation_angle / dt;

    // 更新上一个姿态角度和时间
    previous_yaw = current_yaw;
    previous_time = current_time;

    // 累计总旋转距离
    total_rotation_distance += rotation_distance;

    // 打印当前累计旋转距离和平均旋转速度
    ROS_INFO("Total rotation distance: %.2f meters", total_rotation_distance);
    ROS_INFO("Average rotation speed: %.2f radians/second", average_rotation_speed);
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "rotation_distance_calculation_node");
    ros::NodeHandle nh;

    // 订阅odom话题
    ros::Subscriber sub = nh.subscribe("/odom", 100, odomCallback);

    // 初始化上一个时间
    previous_time = ros::Time::now();

    ros::spin();

    return 0;
}
```



## 使用C++的[getenv]获取env环境变量的信息并使用[字符串比较]对该值做判断

### env指令

在ubuntu中，`env`是一个用于显示或设置环境变量的命令行工具。它可以用来查看当前系统环境变量以及执行特定命令时设置临时的环境变量。

在终端输入`env`即可看到当前系统下的所有环境变量。

### 示例代码

可以使用 `getenv` 函数获取环境变量的值，并进行相应的比较来判断 `robot_type` 的值是否为 "chanmini"。以下是一个示例代码：

```cpp
#include <cstdlib> // 包含 getenv 函数的头文件
#include <iostream>
#include <cstring> // 包含字符串比较函数的头文件

int main() {
    const char* robotType = std::getenv("robot_type");
    if (robotType != nullptr && std::strcmp(robotType, "chanmini") == 0) {
        std::cout << "robot_type is chanmini." << std::endl;
    } else {
        std::cout << "robot_type is not chanmini." << std::endl;
    }

    return 0;
}
```

在上述示例中，使用 `getenv` 函数获取名为 "robot_type" 的环境变量的值，并通过 `std::strcmp` 函数将其与字符串 "chanmini" 进行比较。如果环境变量存在且值为 "chanmini"，则打印相应的提示信息；否则打印另外一条提示信息。

需要注意的是，在比较字符串时，我们使用了 `std::strcmp` 函数来进行安全的字符串比较，以确保准确的比较结果。比较结果为 0 表示两个字符串相等。

另外，`getenv` 函数返回的指针可能为空指针（`nullptr`），表示环境变量不存在或者没有值。因此，在使用返回的指针之前，应该进行空指针检查。



## ROS_INFO打印带参数信息

```cpp
 // 打印当前累计旋转距离和平均旋转速度
    ROS_INFO("Total rotation distance: %.2f meters", total_rotation_distance);
    ROS_INFO("Average rotation speed: %.2f radians/second", average_rotation_speed);
```

